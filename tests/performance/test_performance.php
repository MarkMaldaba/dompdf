<?php
// Remove any limits that might prevent tests from completing.
	ini_set('memory_limit', -1);
	ini_set('max_execution_time', 0);

// Load bootstrap file, which sets up the autoloader appropriately.
	require_once(dirname(__FILE__) . "/../bootstrap.php");

// Define any constants required.
	define("DEFAULT_Iterations", 5000);
	define("PATH_HTMLRoot", dirname(__FILE__) . DIRECTORY_SEPARATOR . "html");
	define("OUTPUT_ColumnWidth", 14);

	define("HEADING_Step",		"Step");
	define("HEADING_Memory",	"Memory use");
	define("HEADING_Peak",		"Peak memory");
	define("HEADING_Time",		"Execution Time");

// If no arguments, report usage and die.
	if ($_SERVER['argc'] < 2) {
		print("Tool to test DomPDF performance when rendering a large amount of "
			  . "HTML.  Uses repeated HTML snippets, normally representing common "
			  . "HTML elements, and reports on maximum memory usage and execution "
			  . "time for the various steps in the process."
			  . PHP_EOL);
		print("The PDF is generated by repeating the HTML in the specified "
			  . "BODY_FILE the specified number of times." . PHP_EOL);
		print("    USAGE:   php " . $_SERVER['argv'][0] . " BODY_FILE [ITERATIONS]"
			  . PHP_EOL);
		print("    EXAMPLE: php " . $_SERVER['argv'][0] . " empty_div 100"
			  . PHP_EOL);
		print("Body files are placed in the 'html' sub-folder, which contains a "
			  . "number of useful examples.  The number of ITERATIONS "
			  . "may be omitted, in which case it defaults to " . DEFAULT_Iterations
			  . "." . PHP_EOL);

		$arrAvailableBodyFiles = scandir(PATH_HTMLRoot);
		if (count($arrAvailableBodyFiles) == 0) {
			print("There are currently no body files available in " . PATH_HTMLRoot
				  . PHP_EOL);
		}
		else {
			print("The following body files are currently available:" . PHP_EOL);
			foreach ($arrAvailableBodyFiles as $FileName) {
				if (substr($FileName, -4) != ".htm")
					continue;

				print("* " . substr($FileName, 0, -4) . PHP_EOL);
			}
		}

		return;
	}

// Get arguments from command-line.
	$BodyFile = $_SERVER['argv'][1];
	if (isset($_SERVER['argv'][2]) && intval($_SERVER['argv'][2]) > 0)
		$Iterations = intval($_SERVER['argv'][2]);
	else
		$Iterations = DEFAULT_Iterations;

// Calculate full path for body file.
	$BodyFilePath = PATH_HTMLRoot . DIRECTORY_SEPARATOR . $BodyFile . ".htm";

// Check file exists.
// If not, report error and die.  Otherwise, load it.
	if (!file_exists($BodyFilePath)) {
		print("ERROR: Body file '" . $BodyFile . "' not found." . PHP_EOL);
		print("Expected location: " . $BodyFilePath . PHP_EOL);
		return;
	}

	$BodyHTML = @file_get_contents($BodyFilePath);
	if ($BodyFilePath === false) {
		print("Error reading body file: " . $BodyFilePath . PHP_EOL);
		return;
	}

// Set up full HTML that will be sent to DomPDF.
	$HTML = "<html><head></head><body>";
	$HTML .= str_repeat($BodyHTML, $Iterations);
	$HTML .= "</body></html>";

// Create new DomPDF object and prepare if for parsing.
	$objDomPDF = new Dompdf\Dompdf();

// Render HTML, logging timings and memory usage along the way.
	$arrTimings = array();
	$arrTimings[] = GetProfilingInfo("Start");

	$objDomPDF->load_html($HTML);
	$arrTimings[] = GetProfilingInfo("Load");

	$objDomPDF->render();
	$arrTimings[] = GetProfilingInfo("Render");

	$objDomPDF->output(array("compress" => 0));
	$arrTimings[] = GetProfilingInfo("Output");

// Generate output report.

	print("Profiling PDF generation using '" . $BodyFile . "' over " . $Iterations
		  . " iterations." . PHP_EOL);

	$arrHeadings = array_keys($arrTimings[0]);
	foreach ($arrHeadings as $Label) {
		print(str_pad(strtoupper($Label), OUTPUT_ColumnWidth));
	}
	print(PHP_EOL);

	foreach ($arrTimings as $Index => $arrRow) {
		foreach ($arrRow as $DataPointName => $DataPoint) {
		// Convert absolute times to relative times.
			if ($DataPointName == HEADING_Time) {
				if ($Index == 0)
					$DataPoint = "-";
				else
					$DataPoint = $DataPoint - $arrTimings[$Index - 1][HEADING_Time];
			}

			print(str_pad($DataPoint, OUTPUT_ColumnWidth));
		}
		print(PHP_EOL);
	}

// END: Main Script
////////////////////////////////////
// HELPER FUNCTIONS

	function GetProfilingInfo($Label) {
		return array(
						HEADING_Step => $Label,
						HEADING_Memory => number_format(memory_get_usage()),
						HEADING_Peak => number_format(memory_get_peak_usage()),
						HEADING_Time => microtime(true),
					);
	}
